<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProStream P2P Broadcast</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- PeerJS for P2P Networking -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        .pulse-live {
            animation: pulse-red 2s infinite;
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(220, 38, 38, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
        }
        /* Lobby Overlay */
        .lobby-backdrop {
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
        }
        
        /* Custom Range Slider Styles */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        
        /* WebKit (Chrome, Safari, Edge) Thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #6366f1; /* indigo-500 */
            cursor: pointer;
            margin-top: -6px; /* Centers thumb on track */
            box-shadow: 0 0 0 4px rgba(30, 27, 75, 0.5); /* indigo-950 ring */
            border: 2px solid white;
        }
        
        /* WebKit Track */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #374151; /* gray-700 */
            border-radius: 4px;
        }

        /* Firefox Thumb */
        input[type=range]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 0 0 4px rgba(30, 27, 75, 0.5);
        }

        /* Firefox Track */
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #374151;
            border-radius: 4px;
        }

        input[type=range]:focus {
            outline: none; 
        }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 h-screen flex flex-col overflow-hidden font-sans selection:bg-purple-500 selection:text-white">

    <!-- Header -->
    <header class="bg-gray-900 border-b border-gray-800 p-4 shadow-2xl z-20">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center space-x-3">
                <div class="w-10 h-10 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center shadow-lg shadow-purple-900/50">
                    <i class="fa-solid fa-satellite-dish text-white text-lg"></i>
                </div>
                <div>
                    <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-indigo-400 to-purple-400 leading-none">
                        ProStream <span class="text-gray-500 font-normal text-sm block">P2P Broadcast Station</span>
                    </h1>
                </div>
            </div>
            
            <div class="flex items-center space-x-4">
                <!-- Status Badge -->
                <div id="statusBadge" class="flex items-center space-x-2 px-4 py-1.5 bg-gray-800 text-gray-400 rounded-full text-xs font-bold border border-gray-700 uppercase tracking-wider transition-colors">
                    <div id="statusDot" class="w-2 h-2 bg-gray-500 rounded-full"></div>
                    <span id="statusText">Offline</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 container mx-auto p-4 md:p-6 flex flex-col md:flex-row gap-6 overflow-hidden relative">
        
        <!-- Viewer Lobby Overlay -->
        <div id="viewerLobby" class="hidden absolute inset-0 z-50 lobby-backdrop flex items-center justify-center p-4">
            <div class="bg-gray-900 border border-gray-700 rounded-2xl shadow-2xl max-w-md w-full p-8 text-center">
                <div class="w-20 h-20 bg-gray-800 rounded-full mx-auto flex items-center justify-center mb-6 shadow-lg shadow-indigo-500/20">
                    <i class="fa-solid fa-play text-3xl text-indigo-400 ml-1"></i>
                </div>
                <h2 class="text-2xl font-bold text-white mb-2">Join Broadcast</h2>
                <p class="text-gray-400 text-sm mb-8">Adjust the slider to match your internet speed.</p>
                
                <div class="space-y-6 text-left bg-gray-800/50 p-6 rounded-xl border border-gray-700">
                    
                    <div class="flex justify-between items-end mb-2">
                        <label class="text-xs font-bold text-gray-400 uppercase tracking-wider">Target Bitrate</label>
                        <span id="sliderValueDisplay" class="text-xl font-bold text-indigo-400">2.5 Mbps</span>
                    </div>

                    <!-- Range Slider -->
                    <div class="relative w-full h-8 flex items-center justify-center">
                        <input type="range" id="bitrateSlider" min="500" max="50000" step="500" value="2500" 
                            class="w-full bg-transparent appearance-none cursor-pointer z-10 relative">
                    </div>
                    
                    <div class="flex justify-between text-[10px] text-gray-500 font-mono mt-1">
                        <span>0.5M</span>
                        <span>10M</span>
                        <span>25M</span>
                        <span>50M</span>
                    </div>

                    <!-- Max Checkbox -->
                    <div class="mt-4 flex items-center justify-between pt-4 border-t border-gray-700">
                        <div class="flex items-center">
                            <input id="maxQualityCheck" type="checkbox" class="w-4 h-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500 focus:ring-2">
                            <label for="maxQualityCheck" class="ml-2 text-sm font-medium text-gray-300">Source Quality (Max)</label>
                        </div>
                        <span class="text-xs text-gray-500">Ignores slider</span>
                    </div>
                </div>

                <button onclick="joinStream()" class="mt-8 w-full py-4 px-4 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white font-bold rounded-lg shadow-lg shadow-indigo-900/30 transform transition-all active:scale-95 flex items-center justify-center gap-2">
                    <i class="fa-solid fa-bolt"></i>
                    Connect Now
                </button>
            </div>
        </div>

        <!-- Left Panel: Controls (Hidden in Viewer Mode) -->
        <div id="controlPanel" class="w-full md:w-80 flex-shrink-0 flex flex-col gap-4 overflow-y-auto pb-4 transition-all duration-500">
            
            <!-- Connection Card -->
            <div class="bg-gray-900/50 backdrop-blur rounded-xl p-5 border border-gray-800 shadow-xl">
                <h2 class="text-xs uppercase tracking-wider text-gray-500 font-bold mb-4">Broadcast Control</h2>
                
                <div class="space-y-3">
                    <button id="startBtn" class="w-full py-4 px-4 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white font-bold rounded-lg shadow-lg shadow-indigo-900/30 transform transition-all active:scale-95 flex items-center justify-center gap-2 group">
                        <i class="fa-solid fa-signal group-hover:animate-ping text-xs"></i>
                        <span>Start Broadcasting</span>
                    </button>
                    
                    <button id="stopBtn" disabled class="w-full py-4 px-4 bg-red-600 hover:bg-red-500 disabled:bg-gray-800 disabled:text-gray-600 disabled:cursor-not-allowed text-white font-bold rounded-lg shadow-lg transform transition-all active:scale-95 flex items-center justify-center gap-2">
                        <i class="fa-solid fa-power-off"></i>
                        Stop Broadcast
                    </button>
                </div>

                <!-- Viewer Link (Appears when live) -->
                <div id="shareSection" class="hidden mt-4 pt-4 border-t border-gray-800 animate-fade-in">
                    <label class="block text-xs font-medium text-green-400 mb-2 flex items-center gap-2">
                        <i class="fa-solid fa-link"></i> Share this link to friends:
                    </label>
                    <div class="flex gap-2">
                        <input type="text" id="shareUrl" readonly class="w-full bg-gray-950 border border-green-900/50 text-gray-300 text-xs rounded p-2 focus:outline-none focus:border-green-500 font-mono">
                        <button id="copyBtn" class="bg-gray-800 hover:bg-gray-700 text-white px-3 rounded border border-gray-700 transition-colors">
                            <i class="fa-regular fa-copy"></i>
                        </button>
                    </div>
                    <div id="viewerCount" class="mt-3 text-xs text-gray-400 flex items-center gap-2">
                        <i class="fa-solid fa-users"></i>
                        <span>Connected Viewers: <b class="text-white">0</b></span>
                    </div>
                </div>
            </div>

            <!-- Configuration -->
            <div class="bg-gray-900/50 backdrop-blur rounded-xl p-5 border border-gray-800 shadow-xl flex-1">
                <h2 class="text-xs uppercase tracking-wider text-gray-500 font-bold mb-4">Stream Settings</h2>
                
                <div class="space-y-5">
                    <!-- Resolution -->
                    <div>
                        <label class="block text-xs font-medium text-gray-400 mb-1">Max Resolution (Source)</label>
                        <div class="relative">
                            <select id="resolutionSelect" class="w-full bg-gray-950 border border-gray-800 text-gray-300 text-sm rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block p-2.5 appearance-none">
                                <option value="0" selected>Native (No Scaling)</option>
                                <option value="720">HD (720p)</option>
                                <option value="1080">Full HD (1080p)</option>
                                <option value="1440">2K (1440p)</option>
                                <option value="2160">4K (2160p)</option>
                            </select>
                            <i class="fa-solid fa-chevron-down absolute right-3 top-3 text-gray-600 pointer-events-none"></i>
                        </div>
                    </div>

                    <!-- Bandwidth Limit -->
                    <div>
                        <label class="block text-xs font-medium text-gray-400 mb-1">Max Bandwidth (Source)</label>
                        <div class="relative">
                            <select id="bandwidthSelect" class="w-full bg-gray-950 border border-gray-800 text-gray-300 text-sm rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block p-2.5 appearance-none">
                                <option value="5000">High (5 Mbps)</option>
                                <option value="10000">Ultra (10 Mbps)</option>
                                <option value="50000">Extreme (50 Mbps)</option>
                                <option value="500000" selected>Ludicrous (500 Mbps)</option>
                            </select>
                            <i class="fa-solid fa-chevron-down absolute right-3 top-3 text-gray-600 pointer-events-none"></i>
                        </div>
                    </div>

                    <!-- Audio -->
                    <div>
                        <label class="block text-xs font-medium text-gray-400 mb-1">Audio Source</label>
                        <div class="flex items-center justify-between bg-gray-950 p-3 rounded-lg border border-gray-800">
                            <div class="flex items-center gap-2">
                                <i class="fa-solid fa-microphone-lines text-indigo-400"></i>
                                <span class="text-sm text-gray-300">Mix Microphone</span>
                            </div>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="micToggle" class="sr-only peer">
                                <div class="w-9 h-5 bg-gray-800 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-indigo-600"></div>
                            </label>
                        </div>
                        
                        <!-- Audio Isolation Hint -->
                        <div class="mt-2 text-[10px] text-gray-500 leading-tight">
                            <span class="text-yellow-500 font-bold">Want to exclude Discord?</span> 
                            Sharing "Entire Screen" captures <span class="italic">all</span> audio. To exclude specific apps, share a specific <span class="text-white">Tab</span> or use a virtual audio cable.
                        </div>
                    </div>

                    <div class="bg-indigo-900/10 border border-indigo-900/30 p-3 rounded-lg">
                        <p class="text-[11px] text-indigo-300 leading-relaxed">
                            <i class="fa-solid fa-microchip mr-1"></i>
                            <strong>High Performance Mode:</strong> Your PC will transcode specific streams for each viewer based on their selection. High CPU/GPU usage expected.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Video Feed -->
        <div class="flex-1 flex flex-col overflow-hidden min-h-0 relative">
            
            <!-- Video Container -->
            <div id="videoContainer" class="relative bg-black rounded-xl border border-gray-800 overflow-hidden shadow-2xl flex-1 flex items-center justify-center group">
                
                <video id="mainVideo" class="max-w-full max-h-full w-full h-full object-contain z-0" autoplay playsinline></video>
                
                <!-- Placeholder / Initial State -->
                <div id="placeholder" class="absolute inset-0 flex flex-col items-center justify-center text-gray-600 z-0">
                    <div class="w-32 h-32 rounded-full bg-gray-900 border border-gray-800 flex items-center justify-center mb-6 group-hover:scale-105 transition-transform duration-500 shadow-2xl shadow-black">
                        <i class="fa-solid fa-tower-broadcast text-5xl text-gray-700"></i>
                    </div>
                    <p class="text-xl font-bold text-gray-500">Signal Offline</p>
                    <p class="text-sm opacity-50 mt-2">Waiting for source...</p>
                </div>

                <!-- Overlay Info -->
                <div id="videoOverlay" class="absolute top-4 left-4 bg-black/70 backdrop-blur-sm border border-white/10 px-3 py-1.5 rounded-md text-xs font-mono text-green-400 hidden z-20 flex items-center gap-3">
                    <div class="flex items-center gap-1">
                        <div class="w-1.5 h-1.5 bg-red-500 rounded-full animate-pulse"></div>
                        <span class="font-bold text-white tracking-wider">LIVE</span>
                    </div>
                    <span class="text-gray-500">|</span>
                    <span id="resDisplay">1080p</span>
                    <span class="text-gray-500">|</span>
                    <span id="qualityTag">Source</span>
                    <span class="text-gray-500">|</span>
                    <!-- Unmute Button Indicator -->
                    <button id="unmuteOverlayBtn" onclick="toggleMute()" class="hidden text-white hover:text-indigo-400">
                        <i class="fa-solid fa-volume-xmark"></i> <span class="ml-1">Unmute</span>
                    </button>
                </div>

                <!-- Viewer Message -->
                <div id="viewerMessage" class="absolute bottom-10 bg-indigo-600/90 text-white px-6 py-3 rounded-full font-bold shadow-lg transform translate-y-20 transition-transform duration-500 hidden z-30">
                    Connected to Stream
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- Configuration ---
        const PEER_CONFIG = {
            debug: 0 // Production mode - no metadata leaks
        };

        // --- Constants ---
        const CONSTANTS = {
            MIC_GAIN: 1.5,
            DUMMY_STREAM_FPS: 30,
            DUMMY_CANVAS_WIDTH: 640,
            DUMMY_CANVAS_HEIGHT: 480,
            IDEAL_FRAMERATE: 60,
            MIN_BITRATE_KBPS: 500,
            MAX_BITRATE_KBPS: 50000,
            BITRATE_STEP: 500,
            DEFAULT_BITRATE_KBPS: 2500,
            COPY_FEEDBACK_DURATION: 2000
        };

        // --- DOM Elements ---
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const mainVideo = document.getElementById('mainVideo');
        const placeholder = document.getElementById('placeholder');
        const controlPanel = document.getElementById('controlPanel');
        const viewerLobby = document.getElementById('viewerLobby');
        const statusBadge = document.getElementById('statusBadge');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const shareSection = document.getElementById('shareSection');
        const shareUrlInput = document.getElementById('shareUrl');
        const copyBtn = document.getElementById('copyBtn');
        const viewerCountEl = document.querySelector('#viewerCount b');
        const videoOverlay = document.getElementById('videoOverlay');
        const resDisplay = document.getElementById('resDisplay');
        const qualityTag = document.getElementById('qualityTag');
        const micToggle = document.getElementById('micToggle');
        const bandwidthSelect = document.getElementById('bandwidthSelect');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const unmuteOverlayBtn = document.getElementById('unmuteOverlayBtn');
        
        // Slider elements
        const bitrateSlider = document.getElementById('bitrateSlider');
        const sliderValueDisplay = document.getElementById('sliderValueDisplay');
        const maxQualityCheck = document.getElementById('maxQualityCheck');

        // --- State Management ---
        const AppState = {
            IDLE: 'idle',
            CONNECTING: 'connecting',
            CONNECTED: 'connected',
            BROADCASTING: 'broadcasting',
            ERROR: 'error',
            DISCONNECTED: 'disconnected'
        };

        class StreamManager {
            constructor() {
                this.peer = null;
                this.stream = null;
                this.audioContext = null;
                this.audioDestination = null;
                this.connections = [];
                this.state = AppState.IDLE;
                this.isHost = true;
                this.targetHostId = null;
            }

            setState(newState) {
                console.log(`State transition: ${this.state} -> ${newState}`);
                this.state = newState;
            }

            getState() {
                return this.state;
            }

            addConnection(connection) {
                this.connections.push(connection);
            }

            removeConnection(connection) {
                this.connections = this.connections.filter(c => c !== connection);
            }

            getConnectionCount() {
                return this.connections.length;
            }

            cleanup() {
                // Clean up peer
                if (this.peer) {
                    this.peer.destroy();
                    this.peer = null;
                }

                // Stop all media tracks
                if (this.stream) {
                    this.stream.getTracks().forEach(track => {
                        track.stop();
                        track.enabled = false;
                    });
                    this.stream = null;
                }

                // Close audio context
                if (this.audioContext) {
                    this.audioContext.close().catch(err => console.warn('AudioContext close error:', err));
                    this.audioContext = null;
                }

                // Clear audio destination
                this.audioDestination = null;

                // Clean up connections
                this.connections.forEach(conn => {
                    try {
                        conn.close();
                    } catch (err) {
                        console.warn('Connection close error:', err);
                    }
                });
                this.connections = [];
            }
        }

        // --- Global Instance ---
        const streamManager = new StreamManager();

        // --- Initialization ---
        const urlParams = new URLSearchParams(window.location.search);
        const hostIdToConnect = urlParams.get('watch');

        if (hostIdToConnect) {
            streamManager.targetHostId = hostIdToConnect;
            streamManager.isHost = false;
            initLobbyMode();
        } else {
            streamManager.isHost = true;
            initHostMode();
        }

        // --- LOBBY LOGIC ---
        function initLobbyMode() {
            streamManager.setState(AppState.IDLE);
            controlPanel.classList.add('hidden');
            viewerLobby.classList.remove('hidden');
            updateStatus('Waiting for selection...', 'yellow');

            // Slider events with validation
            bitrateSlider.addEventListener('input', (e) => {
                const val = Math.max(CONSTANTS.MIN_BITRATE_KBPS, 
                                    Math.min(CONSTANTS.MAX_BITRATE_KBPS, 
                                    parseInt(e.target.value) || CONSTANTS.DEFAULT_BITRATE_KBPS));
                sliderValueDisplay.innerText = (val / 1000).toFixed(1) + ' Mbps';
            });

            maxQualityCheck.addEventListener('change', (e) => {
                if(e.target.checked) {
                    bitrateSlider.disabled = true;
                    bitrateSlider.classList.add('opacity-50', 'cursor-not-allowed');
                    sliderValueDisplay.innerText = 'Max';
                } else {
                    bitrateSlider.disabled = false;
                    bitrateSlider.classList.remove('opacity-50', 'cursor-not-allowed');
                    sliderValueDisplay.innerText = (parseInt(bitrateSlider.value) / 1000).toFixed(1) + ' Mbps';
                }
            });
        }

        window.joinStream = function() {
            // Determine bitrate
            let requestedBitrate = parseInt(bitrateSlider.value);
            let label = (requestedBitrate / 1000).toFixed(1) + ' Mbps';

            if (maxQualityCheck.checked) {
                requestedBitrate = 'max'; // Sentinel value
                label = 'Source';
            }

            viewerLobby.classList.add('hidden');
            streamManager.setState(AppState.CONNECTING);
            updateStatus('Connecting...', 'yellow');
            qualityTag.innerText = label;

            initViewerConnection(requestedBitrate);
        }

        // --- HOST MODE LOGIC ---

        function initHostMode() {
            streamManager.setState(AppState.IDLE);
            
            startBtn.addEventListener('click', async () => {
                startBtn.disabled = true;
                startBtn.innerHTML = '<i class="fa-solid fa-circle-notch fa-spin"></i> Initializing...';
                streamManager.setState(AppState.CONNECTING);

                try {
                    streamManager.stream = await getMediaStream();
                    
                    mainVideo.srcObject = streamManager.stream;
                    mainVideo.muted = true;
                    placeholder.classList.add('hidden');
                    videoOverlay.classList.remove('hidden');
                    qualityTag.innerText = "Host (Source)";
                    
                    streamManager.peer = new Peer(generateRandomId(), PEER_CONFIG);

                    streamManager.peer.on('open', (id) => {
                        console.log('Host ID:', id);
                        streamManager.setState(AppState.BROADCASTING);
                        updateStatus('Broadcasting', 'red');
                        enableLiveUI(id);
                        setupHostEvents();
                    });

                    streamManager.peer.on('error', (err) => {
                        console.error('Peer error:', err);
                        streamManager.setState(AppState.ERROR);
                        alert("Connection Error: " + err.type);
                        resetUI();
                    });

                } catch (err) {
                    console.error("Start Error:", err);
                    streamManager.setState(AppState.ERROR);
                    alert("Could not start capture: " + err.message);
                    resetUI();
                }
            });

            stopBtn.addEventListener('click', stopBroadcast);
        }

        function setupHostEvents() {
            streamManager.peer.on('call', (call) => {
                console.log("Incoming connection:", call.metadata);
                
                // Read requested bitrate from metadata
                let viewerBitrate = call.metadata?.bitrate;
                
                // If 'max' or undefined, use host's max setting
                if (!viewerBitrate || viewerBitrate === 'max') {
                    viewerBitrate = parseInt(bandwidthSelect.value);
                }

                // Advanced SDP Munging for High Bitrate
                const options = {
                    sdpTransform: (sdp) => {
                        try {
                            // 1. Prioritize VP9 (Better compression for high res)
                            sdp = setCodecPreference(sdp, 'VP9');

                            // 2. Set Aggressive Bitrate Limits
                            const kbps = Math.floor(viewerBitrate); 
                            
                            // Set 'b=AS' bandwidth for video
                            if (sdp.indexOf('m=video') !== -1) {
                                // Replace existing b=AS or insert it
                                if (sdp.match(/m=video[\s\S]*?b=AS:\d+/)) {
                                   sdp = sdp.replace(/(m=video[\s\S]*?b=AS:)\d+/, `$1${kbps}`);
                                } else {
                                   sdp = sdp.replace(/(m=video.*)(\r\n)/, `$1$2b=AS:${kbps}$2`);
                                }
                            }

                            // 3. Google-specific "Start Bitrate" hack to avoid slow ramp-up
                            // This forces the browser to try sending high quality immediately
                            // We find the video codec payload and add x-google parameters
                            const minBitrate = Math.min(kbps, 5000); // 5Mbps min start
                            sdp = sdp.replace(/a=mid:video\r\n/g, `a=mid:video\r\na=fmtp:96 x-google-min-bitrate=${minBitrate};x-google-max-bitrate=${kbps};x-google-start-bitrate=${minBitrate}\r\n`);

                            return sdp;
                        } catch (e) {
                            console.error("SDP Transform failed:", e);
                            return sdp;
                        }
                    }
                };

                console.log(`Answering with limit: ${viewerBitrate} kbps`);
                call.answer(streamManager.stream, options);
                
                streamManager.addConnection(call);
                updateViewerCount();

                call.on('close', () => {
                    streamManager.removeConnection(call);
                    updateViewerCount();
                });
                
                call.on('error', () => {
                    streamManager.removeConnection(call);
                    updateViewerCount();
                });
            });
        }

        // Helper to reorder codecs in SDP to prefer VP9
        function setCodecPreference(sdp, codec) {
            const lines = sdp.split('\r\n');
            const mLineIndex = lines.findIndex(line => line.startsWith('m=video'));
            if (mLineIndex === -1) return sdp;

            // Extract payloads
            const mLine = lines[mLineIndex];
            const payloads = mLine.split(' ').slice(3);
            
            // Find payload types for the desired codec
            const codecPayloads = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('a=rtpmap:')) {
                    if (line.includes(codec)) {
                        const payload = line.split(':')[1].split(' ')[0];
                        codecPayloads.push(payload);
                    }
                }
            }

            if (codecPayloads.length === 0) return sdp;

            // Reconstruct m-line with preferred codec first
            const otherPayloads = payloads.filter(p => !codecPayloads.includes(p));
            const newPayloads = [...codecPayloads, ...otherPayloads];
            lines[mLineIndex] = mLine.split(' ').slice(0, 3).join(' ') + ' ' + newPayloads.join(' ');

            return lines.join('\r\n');
        }

        async function getMediaStream() {
            const targetHeight = parseInt(resolutionSelect.value) || 0;
            
            // Setup constraints
            const videoConstraints = {
                frameRate: { ideal: CONSTANTS.IDEAL_FRAMERATE }
            };

            // Only apply height constraint if specific resolution selected (not Native/0)
            if (targetHeight > 0) {
                videoConstraints.height = { ideal: targetHeight };
            }

            // Screen Capture Constraints
            let displayStream;
            try {
                displayStream = await navigator.mediaDevices.getDisplayMedia({
                    video: videoConstraints,
                    audio: true 
                });
            } catch (err) {
                if (err.name === 'NotAllowedError') {
                    throw new Error('Screen sharing permission denied');
                } else if (err.name === 'NotFoundError') {
                    throw new Error('No screen capture source available');
                }
                throw err;
            }

            // Apply Content Hint if supported (Chrome/Edge)
            const videoTrack = displayStream.getVideoTracks()[0];
            if ('contentHint' in videoTrack) {
                videoTrack.contentHint = 'detail'; 
            }

            const settings = videoTrack.getSettings();
            if(settings.width) resDisplay.innerText = `${settings.width}x${settings.height}`;

            if (!micToggle.checked) return displayStream;

            try {
                const micStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                streamManager.audioContext = new AudioContext();
                streamManager.audioDestination = streamManager.audioContext.createMediaStreamDestination();

                if (displayStream.getAudioTracks().length > 0) {
                    const sysSource = streamManager.audioContext.createMediaStreamSource(displayStream);
                    sysSource.connect(streamManager.audioDestination);
                }

                const micSource = streamManager.audioContext.createMediaStreamSource(micStream);
                const micGain = streamManager.audioContext.createGain();
                micGain.gain.value = CONSTANTS.MIC_GAIN; 
                micSource.connect(micGain).connect(streamManager.audioDestination);

                return new MediaStream([
                    ...displayStream.getVideoTracks(),
                    ...streamManager.audioDestination.stream.getAudioTracks()
                ]);

            } catch (e) {
                console.warn("Microphone access failed, using display audio only:", e);
                // Clean up audio context if mic failed
                if (streamManager.audioContext) {
                    streamManager.audioContext.close().catch(err => console.warn('AudioContext close error:', err));
                    streamManager.audioContext = null;
                    streamManager.audioDestination = null;
                }
                return displayStream;
            }
        }

        function stopBroadcast() {
            streamManager.cleanup();
            streamManager.setState(AppState.IDLE);
            resetUI();
        }

        // --- VIEWER CONNECTION LOGIC ---

        function initViewerConnection(bitrate) {
            try {
                streamManager.peer = new Peer(null, PEER_CONFIG);

                streamManager.peer.on('open', (id) => {
                    console.log("Viewer ID:", id);
                    connectToHost(streamManager.targetHostId, bitrate);
                });

                streamManager.peer.on('error', (err) => {
                    console.error('Peer connection error:', err);
                    let errorMsg = 'Connection failed';
                    if (err.type === 'peer-unavailable') {
                        errorMsg = 'Host not found or offline';
                    } else if (err.type === 'network') {
                        errorMsg = 'Network connection failed';
                    } else if (err.type === 'browser-incompatible') {
                        errorMsg = 'Browser not supported';
                    }
                    alert(errorMsg + ': ' + err.type);
                    streamManager.setState(AppState.ERROR);
                    updateStatus('Error', 'gray');
                    viewerLobby.classList.remove('hidden'); 
                });
            } catch (err) {
                console.error('Failed to initialize peer:', err);
                streamManager.setState(AppState.ERROR);
                alert('Failed to initialize connection');
                updateStatus('Error', 'gray');
            }
        }

        function connectToHost(hostId, bitrate) {
            console.log(`Calling host ${hostId} requesting: ${bitrate} kbps`);
            
            const call = streamManager.peer.call(hostId, createDummyStream(), {
                metadata: { bitrate: bitrate }
            });

            call.on('stream', (remoteStream) => {
                streamManager.setState(AppState.CONNECTED);
                updateStatus('Live Signal', 'green');
                
                mainVideo.srcObject = remoteStream;
                mainVideo.muted = true; 
                unmuteOverlayBtn.classList.remove('hidden'); 
                
                placeholder.classList.add('hidden');
                videoOverlay.classList.remove('hidden');

                const playPromise = mainVideo.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        mainVideo.muted = false;
                        if (!mainVideo.muted) {
                            unmuteOverlayBtn.classList.add('hidden');
                        }
                    }).catch(error => {
                        console.warn("Autoplay prevented:", error);
                        placeholder.innerHTML = '<button class="bg-indigo-600 text-white px-6 py-3 rounded-full font-bold shadow-lg hover:scale-105 transition-transform" onclick="mainVideo.muted=false; mainVideo.play(); this.parentElement.classList.add(\'hidden\')"><i class="fa-solid fa-play mr-2"></i> Click to Watch</button>';
                        placeholder.classList.remove('hidden');
                    });
                }

                const toast = document.getElementById('viewerMessage');
                toast.classList.remove('hidden');
                toast.classList.remove('translate-y-20');
            });

            call.on('close', () => {
                updateStatus('Disconnected', 'gray');
                if (confirm('Broadcast ended. Reload page?')) {
                    location.reload();
                }
            });
            
            call.on('error', (err) => {
                console.error('Call error:', err);
                updateStatus('Connection Lost', 'gray');
                alert('Lost connection to host');
            });
        }
        
        window.toggleMute = function() {
            mainVideo.muted = !mainVideo.muted;
            if(mainVideo.muted) {
                unmuteOverlayBtn.innerHTML = '<i class="fa-solid fa-volume-xmark"></i> <span class="ml-1">Unmute</span>';
            } else {
                unmuteOverlayBtn.classList.add('hidden');
            }
        }

        function createDummyStream() {
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const dst = ctx.createMediaStreamDestination();
            osc.connect(dst);
            osc.start();
            const audioTrack = dst.stream.getAudioTracks()[0];
            audioTrack.enabled = false;

            const canvas = document.createElement('canvas');
            canvas.width = CONSTANTS.DUMMY_CANVAS_WIDTH;
            canvas.height = CONSTANTS.DUMMY_CANVAS_HEIGHT;
            const stream = canvas.captureStream(CONSTANTS.DUMMY_STREAM_FPS);
            const videoTrack = stream.getVideoTracks()[0];
            videoTrack.enabled = false;

            return new MediaStream([audioTrack, videoTrack]);
        }

        // --- UI UTILS ---

        function generateRandomId() {
            return 'stream-' + Math.random().toString(36).substr(2, 4) + '-' + Math.random().toString(36).substr(2, 4);
        }

        function enableLiveUI(id) {
            startBtn.innerHTML = '<i class="fa-solid fa-signal"></i> On Air';
            startBtn.classList.add('animate-pulse');
            stopBtn.disabled = false;
            
            const url = new URL(window.location.href);
            url.searchParams.set('watch', id);
            shareUrlInput.value = url.toString();
            
            shareSection.classList.remove('hidden');
            document.getElementById('videoContainer').classList.add('border-red-500', 'pulse-live');
        }

        function resetUI() {
            updateStatus('Offline', 'gray');
            startBtn.disabled = false;
            startBtn.innerHTML = '<i class="fa-solid fa-signal"></i> Start Broadcasting';
            startBtn.classList.remove('animate-pulse');
            stopBtn.disabled = true;
            shareSection.classList.add('hidden');
            
            mainVideo.srcObject = null;
            placeholder.classList.remove('hidden');
            videoOverlay.classList.add('hidden');
            document.getElementById('videoContainer').classList.remove('border-red-500', 'pulse-live');
            viewerCountEl.innerText = '0';
        }

        function updateViewerCount() {
            if (viewerCountEl) {
                viewerCountEl.innerText = streamManager.getConnectionCount();
            }
        }

        function updateStatus(text, color) {
            statusText.innerText = text;
            statusDot.className = `w-2 h-2 rounded-full ${getColorClass(color)}`;
            statusBadge.className = `flex items-center space-x-2 px-4 py-1.5 rounded-full text-xs font-bold border uppercase tracking-wider transition-colors ${getBadgeClass(color)}`;
        }

        function getColorClass(color) {
            if(color === 'red') return 'bg-red-500 animate-pulse';
            if(color === 'green') return 'bg-green-500';
            if(color === 'yellow') return 'bg-yellow-500 animate-pulse';
            return 'bg-gray-500';
        }

        function getBadgeClass(color) {
            if(color === 'red') return 'bg-red-900/30 text-red-400 border-red-900/50';
            if(color === 'green') return 'bg-green-900/30 text-green-400 border-green-900/50';
            if(color === 'yellow') return 'bg-yellow-900/30 text-yellow-400 border-yellow-900/50';
            return 'bg-gray-800 text-gray-400 border-gray-700';
        }

        copyBtn.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(shareUrlInput.value);
                const originalIcon = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fa-solid fa-check text-green-400"></i>';
                setTimeout(() => copyBtn.innerHTML = originalIcon, CONSTANTS.COPY_FEEDBACK_DURATION);
            } catch (err) {
                console.error('Failed to copy:', err);
                // Fallback for older browsers
                shareUrlInput.select();
                try {
                    document.execCommand('copy');
                    const originalIcon = copyBtn.innerHTML;
                    copyBtn.innerHTML = '<i class="fa-solid fa-check text-green-400"></i>';
                    setTimeout(() => copyBtn.innerHTML = originalIcon, CONSTANTS.COPY_FEEDBACK_DURATION);
                } catch (fallbackErr) {
                    alert('Failed to copy to clipboard');
                }
            }
        });

    </script>
</body>
</html>